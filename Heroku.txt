Heroku: - ingyenes tárhelyet biztosít és szerver szolgáltatásokat
		- ide fel tudjuk tenni az alkalmazásunkat
		- az alkalmazásokhoz általában kapcsolódik egy adatbázis is, aminek szintén kell egy szerver, ahol él
		- tehetjük egy szerverre az alkalmazást és az adatbázist, de külön szerveren is lehetnek
		- az adatbázisnak is minden esetben egy szerveren kell élnie, ezen fut egy operációs rendszer és e fölött fut az adatbázis keretrendszer (pl.: postgreSQL)
		- a Heroku automatikusan megcsinál mindent és ad egy szerver környezetet
		
Példa:
	Az adatbázist tesszük fel Heroku-ra, és az alkalmazásunkból csatlakozunk ehhez a távoli szerverhez.
	Heroku beállítása:
		- create new app -> adatok kitöltése (az alkalmazás neve kisbetűvel kell kezdődjön)
		- data.heroku.com: ha már van egy alkalmazásunk, akkor lehetőség van létrehozni egy adatbázis környezetet itt.
			-> Heroku Postgres -> create one
			-> Install Heroku Postgres
			-> kiválasztjuk, hogy melyik alkalmazáshoz telepítse az adatbázist (korábban létrehozott szerverkörnyezet a create new appal)
	Datastore->Settings->Database Credentials->View: adatbázis felhasználó név/ jelszó/ elérési út
	Project beállítások:
		pom.xml: jpa
				 postgreSQL
				 thymeleaf
	Application.properties: meg kell adni a távoli adatbázis adatait
			url=jdbc: adatbázistípus://elérési út:port/adatbázisnév?egyéb beállítások
			pl. ssl= true -> mivel a heroku nem enged hitelesítés nélküli kapcsolódást
		spring.datasource.url=jdbc:postgresql://ec2-54-217-236-206.eu-west-1.compute.amazonaws.com:5432/d7nmvq8g4g5jqg?ssl=true&sslfactory=org.postgresql.ssl.NonValidatingFactory
		spring.datasource.username=kidqoccfuweiti
		spring.datasource.password=e518d0b534f5df0db33c79b16a2b22f2cbdb95b7bdaa55f5dc2e04737664e9f1
			Itt adjuk meg, hogy milyen drivert akarunk használni (melyik konnektorra van szüksége a jdbcnek, adatbázis típusonként más)				
		spring.datasource.driverClassName=org.postgresql.Driver
			Itt adjuk meg a jpa-nak milyen dialektust használjon
		spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
			A jpa-t különböző funkciókkal tudjuk meghívni: Célszerű első indításkor create-el futtatni, majd átállítani update-re
				- create: amikor elindul a szerver felcsatlakozik az adatbázishoz, az entytik alapján létrehozza a táblákat,
							   megfuttatja az sql fájlt, hogy feltöltse a táblákat, ha van ilyenünk.
				- create-drop: amikor elindul a szerver felcsatlakozik az adatbázishoz, az entytik alapján létrehozza a táblákat,
							   megfuttatja az sql fájlt, hogy feltöltse a táblákat, ha van ilyenünk. Majd ha leállítjuk a szervert törli az egészet. (hasonlít a H2 adatbázishoz)
				- update: frissítse az adatbázist, ha van különbség a struktúrában, pl. létrehoztun egy új entityt. Ilyenkor nem lehet + sql fájl és amit előző szerver indításkor kódból töltöttünk azt most ki kell kommentelni.
				- validate: ellenőrizze, hogy van-e különbség, de nem végez módosítást
		spring.jpa.hibernate.ddl-auto=create-drop
		spring.datasource.initialization-mode=always
		spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = false
		A tábla nevek kisbetűsek kell legyenek, ezért az Entity mellett a name-l át kell nevezni
			pl.: @Entity(name="bloggerek")
			