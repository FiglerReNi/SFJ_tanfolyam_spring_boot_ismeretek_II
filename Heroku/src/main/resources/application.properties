spring.thymeleaf.cache=false

#A heroku nem enged hitelesítás nélküli kapcsolódást, ezért az útvonalba kell a ? utáni ssl rész
spring.datasource.url=jdbc:postgresql://ec2-54-217-236-206.eu-west-1.compute.amazonaws.com:5432/d7nmvq8g4g5jqg?ssl=true&sslmode=require&sslfactory=org.postgresql.ssl.NonValidatingFactory

spring.datasource.username=kidqoccfuweiti

spring.datasource.password=e518d0b534f5df0db33c79b16a2b22f2cbdb95b7bdaa55f5dc2e04737664e9f1

#Itt adjuk meg, hogy milyen drivert akarunk használni (melyik konnektorra van szüksége a jdbcnek, adatbázis típusonként más)
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.initialization-mode=always

#Itt adjuk meg a jpa-nak milyen dialektust használjon, mivel van eltérés a mysql és a postgre szintaktikája között például
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = false

#A jpa-t különböz? funkciókkal tudjuk meghívni: Célszer? els? indításkor create-el futtatni, majd átállítani update-re
#    create: amikor elindul a szerver felcsatlakozik az adatbázishoz, az entytik alapján létrehozza a táblákat,megfuttatja az sql fájlt, hogy feltöltse a táblákat, ha van ilyenünk.
#    create-drop: amikor elindul a szerver felcsatlakozik az adatbázishoz, az entytik alapján létrehozza a táblákat, megfuttatja az sql fájlt, hogy feltöltse a táblákat, ha van ilyenünk. Majd ha leállítjuk a szervert törli az egészet. (hasonlít a H2 adatbázishoz)
#    update: frissítse az adatbázist, ha van különbség a struktúrában, pl. létrehoztun egy új entityt. Ilyenkor nem lehet + sql fájl és amit el?z? szerver indításkor kódból töltöttünk azt most ki kell kommentelni.
#    validate: ellen?rizze, hogy van-e különbség, de nem végez módosítást
spring.jpa.hibernate.ddl-auto=create
