
	

		

		
Cross-site request forgery:
	internet biztonsági kockázatok:
		- különböző adatok ellopása 
		- banki utalás a felhasználó saját számlájáról
		- jelszófeltörések mellett sokkal jelentősebbek az egyéb eszközök
			- a http ürlapokat, kitölthető formokat lehet másolni
			- a bank oldalán például kitöltöm a felhasználónevem és jelszavam + amit még kérnek, majd cerébe kapok egy tokent, ami azonosít, amíg a bank oldalán vagyok. Ezt tárolja a böngésző.
			- a pénzküldés felületen is egy űrlapot töltünk ki, majd küldés gomb. Az adatok Post-tal a bodyba kerülnek, ez biztonságosabb mint a get.
			- a hackerek küldenek sok embernek emailt, egy linkkel hogy jelentkezzenek be a bankjukba például:
				- vagy kamu oldalra visz a link, ahol ellopják a jelszót és felhasználó nevet
				- vagy egy ártalmatlan oldalra vezetnek, ahol írok egy kommentet stb és rányomok a küldés gombra, a háttérben ezen az oldalon van definiálva egy form kitöltve összeggel számlaszámmal, és mondjuk ha nem rég voltam bejelentkezve a bankomba akkor a böngészőm még mindig lehet őrzi azt a tokent. Így a küldés gombra elmegy a banknak a kérés.
	amit tehetünk:
		- jó jelszó és minde oldalra más
		- a bankok minden serverükre irányuló kérés esetén elkérik, hogy honnan érkezik a kérés (referer field - headerben van): banknak az oldaláról, vagy máshonnan, másik serverről. Ez nem mindig tud működni, van, hogy nem kerül bele a lekérés header részébe hogy honnan jön a kérés, a különböző böngészők, kiegészítő szoftverek, reklámblokkolók stb miatt.
		A header rész hamisítható is.
		- a bankok új módszere: a server a backendről a frontendre küld egy véletlen generált karakter sorozatot
			ez a CSRF token (Cross-site request forgery token)
			ezt egy hidden mezőben mellékelik a háttérben a formhoz, vagyis a hiteles oldalon ott lesz a token amikor elküldöm a lekérést és össze tudja hasonlítani a szerver a kiadott és kapottt tokent. A hacker hiába másolja le a formot, nem fogja tudni a véletlen számot hozzá.
	A Spring Bootban a CSRF token technológia alapból aktiválva van a login formhoz.

FrontEnd:
	- a thymeleafnek van egy securityhez tartozó dependencyje: (ezzel elérünk bizonyos adatokat)
			<dependency>
				<groupId>org.thymeleaf.extras</groupId>
				<artifactId>thymeleaf-extras-springsecurity4</artifactId>
				<version>2.1.2.RELEASE</version>
			</dependency>
	- namespace: xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-spring-security4"
	- ha saját login oldalt csinálunk, gondosodnunk kell róla, hogy erről az oldalról a beérkező adatok (felhasználónév + jelszó) vissza kerüljön a Spring Securityhez és elvégezhesse a bejelentkeztető folyamatot.
	Ehhez olyan formra van szükség aminek 3 fix része tuti van: felhasználónév + jelszó + mentés gomb.
	Visszairányítás a form tagben: th:action="@{/login}" --> így a spring securityhez kerülnek a bekért adatok
	- alapból csak a login és logout oldalt tesszük elérhetővé. Bárhová akar menni a felhasználó nem tudja elérni. Ha bejelentkezett, akkor arra az oldalra/aloldalra kerül, amit eredetileg beírt a böngészőbe.
	- nézetet és útvonalat több féle módon köthetünk össze:
		- controllerrel (@Controller + @RequestMapping)
		- olyan osztállyal ami implementálja a WebMvcConfigurer interfacet, itt ki tudjuk kérni a registry-t ami tárol kapcsolódási pontokat a nézetek és az útvonalak között. És ebbe bele tudunk nyúlni.
	- a security segítségével és a thymeleaf-el egyszerűen tudjuk szabályozni, hogymit lehessen csak bejelentkezve látni egy oldalon. Pl.: melyik html elemet: sec:authorize="isAuthenticated()" --> ezzel vizsgáljuk, hogy be van-e jelentkezve és ha igen csak akkor jelenik meg az adott elem.
	
Bejelentkezés saját Login oldalról:
	- át kell adnunk a bekért adatokat a Spring Securitynek a bejelenteztetés végrehajtásához
	- UserDetails interfacet kell kiterjeszteni, az adatok átadásához, és itt adjuk meg hogy az adatbázisból kiolvasott adatokat vizsgálja. 
	- Megmondjuk, hogy a mi osztályunkat használja az eredeti működés helyett. Ehhez ki kell terjesteni a UserDetailsService-t valamelyik serviceünkben, vagy újat is csinálhatunk neki.
	- loadUserByUsername-t felül kell írni és átadni a mi user objektumunkat, amit az adatbázisból kerestünk ki.
	
Adatbázisba mentés:
	- UserService interface-ben registerUser function
	- kiterjesztjü a UserServiceImpl osztállyal és felülírjuk a methodot --> megmondjuk pontosan mit csináljon
	- majd meghívjuk a HomeControllerben, ahol a felületről visszakapunk egy usert (amit el akarunk menteni) és átadjuk neki
	- érdemes vizsgálni az email címet, hogy szerepel-e már az adatbázisban és jelezni a felhasználónak, ha van már ilyen emaillel regisztráció
	
Aktiválás:
	- két új mező a user tánlához:
		-enabled és activation
	- ellenőrizzük, hogy szerepel e már az email cím (regisztráltek-e már vele)
	- enable alapból false
	- activationhoz pedig generálunk egy kulcsot
	- elküldjük emailben (application.properties-be a honlap linkjét és onnan veszzük i ezt az értéket)
	- linkre attintva a linkből kivesszük a kódot és ellenőrizzük adatbázisban
	- engedélyeznünk kell belépés nélkül az aktiváció + kód linkeket a configban
