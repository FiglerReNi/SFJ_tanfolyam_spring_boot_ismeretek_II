
	

		

		


FrontEnd:
	- a thymeleafnek van egy securityhez tartozó dependencyje: (ezzel elérünk bizonyos adatokat)
			<dependency>
				<groupId>org.thymeleaf.extras</groupId>
				<artifactId>thymeleaf-extras-springsecurity4</artifactId>
				<version>2.1.2.RELEASE</version>
			</dependency>
	- namespace: xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-spring-security4"
	- ha saját login oldalt csinálunk, gondosodnunk kell róla, hogy erről az oldalról a beérkező adatok (felhasználónév + jelszó) vissza kerüljön a Spring Securityhez és elvégezhesse a bejelentkeztető folyamatot.
	Ehhez olyan formra van szükség aminek 3 fix része tuti van: felhasználónév + jelszó + mentés gomb.
	Visszairányítás a form tagben: th:action="@{/login}" --> így a spring securityhez kerülnek a bekért adatok
	- alapból csak a login és logout oldalt tesszük elérhetővé. Bárhová akar menni a felhasználó nem tudja elérni. Ha bejelentkezett, akkor arra az oldalra/aloldalra kerül, amit eredetileg beírt a böngészőbe.
	- nézetet és útvonalat több féle módon köthetünk össze:
		- controllerrel (@Controller + @RequestMapping)
		- olyan osztállyal ami implementálja a WebMvcConfigurer interfacet, itt ki tudjuk kérni a registry-t ami tárol kapcsolódási pontokat a nézetek és az útvonalak között. És ebbe bele tudunk nyúlni.
	- a security segítségével és a thymeleaf-el egyszerűen tudjuk szabályozni, hogymit lehessen csak bejelentkezve látni egy oldalon. Pl.: melyik html elemet: sec:authorize="isAuthenticated()" --> ezzel vizsgáljuk, hogy be van-e jelentkezve és ha igen csak akkor jelenik meg az adott elem.
	
Bejelentkezés saját Login oldalról:
	- át kell adnunk a bekért adatokat a Spring Securitynek a bejelenteztetés végrehajtásához
	- UserDetails interfacet kell kiterjeszteni, az adatok átadásához, és itt adjuk meg hogy az adatbázisból kiolvasott adatokat vizsgálja. 
	- Megmondjuk, hogy a mi osztályunkat használja az eredeti működés helyett. Ehhez ki kell terjesteni a UserDetailsService-t valamelyik serviceünkben, vagy újat is csinálhatunk neki.
	- loadUserByUsername-t felül kell írni és átadni a mi user objektumunkat, amit az adatbázisból kerestünk ki.
	
Adatbázisba mentés:
	- UserService interface-ben registerUser function
	- kiterjesztjü a UserServiceImpl osztállyal és felülírjuk a methodot --> megmondjuk pontosan mit csináljon
	- majd meghívjuk a HomeControllerben, ahol a felületről visszakapunk egy usert (amit el akarunk menteni) és átadjuk neki
	- érdemes vizsgálni az email címet, hogy szerepel-e már az adatbázisban és jelezni a felhasználónak, ha van már ilyen emaillel regisztráció
	
Aktiválás:
	- két új mező a user tánlához:
		-enabled és activation
	- ellenőrizzük, hogy szerepel e már az email cím (regisztráltek-e már vele)
	- enable alapból false
	- activationhoz pedig generálunk egy kulcsot
	- elküldjük emailben (application.properties-be a honlap linkjét és onnan veszzük i ezt az értéket)
	- linkre attintva a linkből kivesszük a kódot és ellenőrizzük adatbázisban
	- engedélyeznünk kell belépés nélkül az aktiváció + kód linkeket a configban
