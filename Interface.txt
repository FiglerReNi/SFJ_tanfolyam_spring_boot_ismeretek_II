Interface: 
	- Csak beregisztrálja a functionokat, de nem mondja meg hogyan/mit csinál
	- Aki kiterjeszti annak kötelező meghatározi a benne foglalt functionok működését
	- Ha egy functiont több osztály is használ, akkor interface-ben határozhatjuk meg ezt.
	- Vannak marker interfacek, amiben nincs semmilyen function amit felül kellene írni, de plusz képességet tud adni egy osztálynak. Nem fontos hogy a háttérben hogy működik, az a lényeg, hogy ami nekünk kell azt tudja. pl. serializable, CrudRepository
	- Sok cég ragaszkodik hozzá, hogy interface-t használjunk. A Servive réteget ne csak önmagában hozzuk létre, hanem legyen hozzá interface és ezt használjuk a service rétegben.

Interface nélkül:
@Servive annotációval látom el az osztály és megírom benne a functionokat, hogy mi mit csináljon. Aki meghívja, annak tudnia kell mit csinál az a function. 

Interfaceel:
Nagyobb projekteknél lehet fontos, itt egy interfacben megmondjuk, hogy pl aki kiterjeszti kell csináljon egy save functiont, de más-más osztályokban másképp fog működni ez a save function. Például beregisztrál egy felhasználó, és egyszer arra van szükségünk, hogy adatbázisba mentsük, egyszer arra hogy mondjuk xml-be, vagy más fajta adatbázisba mentjük. Logikailag ez ugyanaz, adatfeldolgozás mindegyik változat. Ha nem használunk interfacet a service classban írunk 3-4 functiont, majd a controllerben meghívjuk épp amelyik kell. Ha módosul, hogy melyikre van szüség, mindenhol ki kell cserélni a kódban.
Erre csinálhatunk egy interfacet, ami annyit mond hogy save(); majd a 3-4 módra csinálunk service classokat külön-külön, amik kitejesztik az interface-t. Majd a controllerben az interface.save-et hívjuk meg mindig, és csak az injektálásnál jelezzük, hogy melyik ezt kiterjesztő osztály kell nekünk (így kevesebb helyen kell átírni):
	@Autowired
	@Qualifier("pl.:3.módszer -- vagyis melyik osztály kell")
	Intefaceünk neve
Átláthatóbbá teszi a kódot, és ha módosítunk az interfacben kötelezően kell az osztályokban is.

Példánkban:
A változat interface nélkül
	UserRepository 
	UserServiceImpl --> ebben használjuk a findByEmail-t a repositoryból és csinálunk egy functiont findByEmail néven
	
B változat interfaccel
	UserRepository
	UserService (interface) --> ebben regisztráljuk a létrehozni kívánt findByEmail functiont
	UserServiceImpl --> kiterjeszti az interface-t így kötelező bele a findByEmail function, amiben használjuk a repoból a findByEmail-t
	
Az interfaceket és a serviceket gyakran külön package-be teszik
	